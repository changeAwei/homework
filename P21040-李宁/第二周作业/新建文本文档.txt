1. 简要说明Python垃圾回收机制
	Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。
	【引用计数】PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。
	优点:				
	1、简单
	2、实时性
	缺点:
	1、维护引用计数消耗资源
	2、循环引用

	【标记-清除机制】
	基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

	【分代技术】
	分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。
	Python默认定义了三代对象集合，索引数越大，对象存活时间越长。
	举例：
	当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟

2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
	斐波那契数列：第一项1 第二项1 从第三项开始数字等于前两项之和，即f(n)=f(n-1)+f(n-2)
	质数又称素数。指在一个大于1的自然数中,除了1和此整数自身外,没法被其他自然数整除的数。
	猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第十天早上在想吃时，就只剩一个桃子了。求第一天共摘了多少个桃子？

3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
	list.append() 尾部追加
	list.pop() 尾部弹出,还可以指定索引
	list.remove(value) 移除元素
	list.count() 计数器
	list.index(value) 查找元素所在的索引
	list.reverse() 列表反转
	list.clear() 清空列表
	list.insert(index, value) 在索引处插入值
	list.sort() 按照ASCII进行排序
	
4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 
	
while True:
    num1 = int(input('请输入第一个数字： '))
    opera = input('请输入操作符（+ - * /）： ')
    num2 = int(input('请输入第二个数字： '))


    if opera == '+':
        print('加法运算', num1 + num2)
    elif opera == '-':
        print('减法运算', num1 - num2)
    elif opera == '*':
        print('乘法运算', num1 * num2)
    elif opera == '/':
        print('除法运算', num1 / num2)
    else:
        print('非法操作')
        break
