3. 请写出字符串支持的所有方法及说明（例如: lower 返回字符串的小写）
字符串的定义和初始化方法：
	str(object='') -> str：利用一个字符串来初始化自身，例如：s = 'eee',s2 = str(s),或者是：s3 = str('ddd')	
	str(bytes_or_buffer[, encoding[, errors]]) -> str
	根据字节（bytes）进行构造字符串，使用encoding指定编码格式,默认是系统中的编码方式（sys.getdefaultencoding()），
	errors？，默认是'strict'
字符串常用方法（依据help(str)而来）	
	capitalize():返回字符串，首字母大写
	casefold()：返回一个字符串，类似lower()方法，不过lower()方法只对英文起作用
		In [1]: s = 'dyegadudhenndkeidund'                                                       
		In [2]: s.casefold()                                                                     
		Out[2]: 'dyegadudhenndkeidund'
		In [3]: s = 'TeddIITITI丁常祥'                                                           
		In [4]: s.casefold()                                                                     
		Out[4]: 'teddiititi丁常祥'
		In [5]: s.lower()                                                                        
		Out[5]: 'teddiititi丁常祥'
		In [6]: s
		Out[6]: 'TeddIITITI丁常祥'

	center()：返回长度为width的字符串，左右以fillchar来填充，fillchar默认是空格
		S.center(width[, fillchar])
	count()：返回参数
		S.count(sub[, start[, end]])

 encode(...)
     S.encode(encoding='utf-8', errors='strict') -> bytes
     
     Encode S using the codec registered for encoding. Default encoding
     is 'utf-8'. errors may be given to set a different error
     handling scheme. Default is 'strict' meaning that encoding errors raise
     a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and
     'xmlcharrefreplace' as well as any other name registered with
     codecs.register_error that can handle UnicodeEncodeErrors.
 
 endswith(...)
     S.endswith(suffix[, start[, end]]) -> bool
     
     Return True if S ends with the specified suffix, False otherwise.
     With optional start, test S beginning at that position.
     With optional end, stop comparing S at that position.
     suffix can also be a tuple of strings to try.
 
 expandtabs(...)
     S.expandtabs(tabsize=8) -> str
     
     Return a copy of S where all tab characters are expanded using spaces.
     If tabsize is not given, a tab size of 8 characters is assumed.
 
 find(...)
     S.find(sub[, start[, end]]) -> int
     
     Return the lowest index in S where substring sub is found,
     such that sub is contained within S[start:end].  Optional
     arguments start and end are interpreted as in slice notation.
     
     Return -1 on failure.
 
 format(...)
     S.format(*args, **kwargs) -> str
     
     Return a formatted version of S, using substitutions from args and kwargs.
     The substitutions are identified by braces ('{' and '}').
 
 format_map(...)
     S.format_map(mapping) -> str
     
     Return a formatted version of S, using substitutions from mapping.
     The substitutions are identified by braces ('{' and '}').
 
 index(...)
     S.index(sub[, start[, end]]) -> int
     
     Like S.find() but raise ValueError when the substring is not found.
 
 isalnum(...)
     S.isalnum() -> bool
     
     Return True if all characters in S are alphanumeric
     and there is at least one character in S, False otherwise.
 
 isalpha(...)
     S.isalpha() -> bool
     
     Return True if all characters in S are alphabetic
     and there is at least one character in S, False otherwise.
 
 isdecimal(...)
     S.isdecimal() -> bool
     
     Return True if there are only decimal characters in S,
     False otherwise.
 
 isdigit(...)
     S.isdigit() -> bool
     
     Return True if all characters in S are digits
     and there is at least one character in S, False otherwise.
 
 isidentifier(...)
     S.isidentifier() -> bool
     
     Return True if S is a valid identifier according
     to the language definition.
     
     Use keyword.iskeyword() to test for reserved identifiers
     such as "def" and "class".
 
 islower(...)
     S.islower() -> bool
     
     Return True if all cased characters in S are lowercase and there is
     at least one cased character in S, False otherwise.
 
 isnumeric(...)
     S.isnumeric() -> bool
     
     Return True if there are only numeric characters in S,
     False otherwise.
 
 isprintable(...)
     S.isprintable() -> bool
     
     Return True if all characters in S are considered
     printable in repr() or S is empty, False otherwise.
 
 isspace(...)
     S.isspace() -> bool
     
     Return True if all characters in S are whitespace
     and there is at least one character in S, False otherwise.
 
 istitle(...)
     S.istitle() -> bool
     
     Return True if S is a titlecased string and there is at least one
     character in S, i.e. upper- and titlecase characters may only
     follow uncased characters and lowercase characters only cased ones.
     Return False otherwise.
 
 isupper(...)
     S.isupper() -> bool
     
     Return True if all cased characters in S are uppercase and there is
     at least one cased character in S, False otherwise.
 
 join(...)
     S.join(iterable) -> str
     
     Return a string which is the concatenation of the strings in the
     iterable.  The separator between elements is S.
 
 ljust(...)
     S.ljust(width[, fillchar]) -> str
     
     Return S left-justified in a Unicode string of length width. Padding is
     done using the specified fill character (default is a space).
 
 lower(...)
     S.lower() -> str
     
     Return a copy of the string S converted to lowercase.
 
 lstrip(...)
     S.lstrip([chars]) -> str
     
     Return a copy of the string S with leading whitespace removed.
     If chars is given and not None, remove characters in chars instead.
 
 partition(...)
     S.partition(sep) -> (head, sep, tail)
     
     Search for the separator sep in S, and return the part before it,
     the separator itself, and the part after it.  If the separator is not
     found, return S and two empty strings.
 
 replace(...)
     S.replace(old, new[, count]) -> str
     
     Return a copy of S with all occurrences of substring
     old replaced by new.  If the optional argument count is
     given, only the first count occurrences are replaced.
 
 rfind(...)
     S.rfind(sub[, start[, end]]) -> int
     
     Return the highest index in S where substring sub is found,
     such that sub is contained within S[start:end].  Optional
     arguments start and end are interpreted as in slice notation.
     
     Return -1 on failure.
 
 rindex(...)
     S.rindex(sub[, start[, end]]) -> int
     
     Like S.rfind() but raise ValueError when the substring is not found.
 
 rjust(...)
     S.rjust(width[, fillchar]) -> str
     
     Return S right-justified in a string of length width. Padding is
     done using the specified fill character (default is a space).
 
 rpartition(...)
     S.rpartition(sep) -> (head, sep, tail)
     
     Search for the separator sep in S, starting at the end of S, and return
     the part before it, the separator itself, and the part after it.  If the
     separator is not found, return two empty strings and S.
 
 rsplit(...)
     S.rsplit(sep=None, maxsplit=-1) -> list of strings
     
     Return a list of the words in S, using sep as the
     delimiter string, starting at the end of the string and
     working to the front.  If maxsplit is given, at most maxsplit
     splits are done. If sep is not specified, any whitespace string
     is a separator.
 
 rstrip(...)
     S.rstrip([chars]) -> str
     
     Return a copy of the string S with trailing whitespace removed.
     If chars is given and not None, remove characters in chars instead.
 
 split(...)
     S.split(sep=None, maxsplit=-1) -> list of strings
     
     Return a list of the words in S, using sep as the
     delimiter string.  If maxsplit is given, at most maxsplit
     splits are done. If sep is not specified or is None, any
     whitespace string is a separator and empty strings are
     removed from the result.
 
 splitlines(...)
     S.splitlines([keepends]) -> list of strings
     
     Return a list of the lines in S, breaking at line boundaries.
     Line breaks are not included in the resulting list unless keepends
     is given and true.
 
 startswith(...)
     S.startswith(prefix[, start[, end]]) -> bool
     
     Return True if S starts with the specified prefix, False otherwise.
     With optional start, test S beginning at that position.
     With optional end, stop comparing S at that position.
     prefix can also be a tuple of strings to try.
 
 strip(...)
     S.strip([chars]) -> str
     
     Return a copy of the string S with leading and trailing
     whitespace removed.
     If chars is given and not None, remove characters in chars instead.
 
 swapcase(...)
     S.swapcase() -> str
     
     Return a copy of S with uppercase characters converted to lowercase
     and vice versa.
 
 title(...)
     S.title() -> str
     
     Return a titlecased version of S, i.e. words start with title case
     characters, all remaining cased characters have lower case.
 
 translate(...)
     S.translate(table) -> str
     
     Return a copy of the string S in which each character has been mapped
     through the given translation table. The table must implement
     lookup/indexing via __getitem__, for instance a dictionary or list,
     mapping Unicode ordinals to Unicode ordinals, strings, or None. If
     this operation raises LookupError, the character is left untouched.
     Characters mapped to None are deleted.
 
 upper(...)
     S.upper() -> str
     
     Return a copy of S converted to uppercase.
 
 zfill(...)
     S.zfill(width) -> str
     
     Pad a numeric string S with zeros on the left, to fill a field
     of the specified width. The string S is never truncated.

