1. 简要说明Python垃圾回收机制
引用对象被引用时引用次数加一，被替换时减一，当系统内存快不够时，Python会自动清理引用次数为0的数据。
例如：
homework = 'abssd'	#字符串'abssd'引用次数加一
homework = ['abssd',123]	#字符串'abssd'引用次数减一，如果Python此时要进行垃圾回收就会清理这个字符串，同时列表['abssd',123]引用次数加一，如果homework再被重新定义，列表['abssd',123]引用次数也会减一，如果引用次数为0，也会被清理掉

2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
斐波那契数列：以1为第一项（0为第0项），每一项是前两项之和
素数/质数：仅能被1和自身整除的，大于1的自然数，特征：偶数除了2以外全部都不是质数，质数与6相邻（质数肯定在6的倍数前一个或后一个）
猴子吃桃：猴子吃桃每天吃一半加一个(a = a // 2 - 1)，第n天后只有1个，求第一天有多少个；逆向求值，最后一天1个a = 1(最后一天数量)，前一天数量为a = (a + 1) * 2，用for循环可以求出第一天数量，注意循环次数为n - 1次

3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
列表:一个排列整齐的队列，线性的、可变的、可迭代的，正索引从0开始从左往右，负索引从-1开始从右往左，索引不可超界，否则报异常。list[index]，index为索引
列表建立：list()加可迭代对象，直接使用符号[]建立（[]符号内有可迭代对象不会迭代拿出来，而是当做一个元素存放在列表内）
增：
list.append(object):
向列表末尾添加元素(O(1)时间复杂度,大批量增加效率低，需不断开辟内存空间)，返回None，就地修改
list.extend():
将可迭代对象的元素从末尾追加进来,(O(1)时间复杂度)，返回None，就地修改
list.insert(index,object):
在索引index处插入元素，后面元素全部往后移1位(O(n)时间复杂度,效率低,少做最好不做)，返回None，就地修改
list1 + list2:
将两个列表连接起来，返回一个新列表，原列表不变
list * n:
将列表元素重复n次，返回新列表（浅拷贝：如果原列表元素中含有标识符、列表、set、字典等，如果这些元素改变，n次出来的元素也会跟着改变），原列表不变
删：
list.remove(value):
从列表中左往右查找删除第一个匹配value的值（移除一个或者不移除（没找到）），（需遍历，时间复杂度O（n）），就地修改，返回None
list.pop([index]):
不指定索引则从末尾删除一个元素，O(1)，返回末尾那个元素
指定索引则删除索引处元素，O(n)（删除后后面元素需全部前移，效率低），返回指定索引对应的元素
list.clear():
清空列表，慎用！
改：
list[index] = value: 将指定索引处的元素更改
list.reverse():
将列表元素反转，O(n)，就地修改，返回None
list.sort([key = None],[reverse = False]):
对列表进行排序，默认False升序，改为True则为降序，O(n)
（未学）可以key一个函数，按指定规则排序
查：
list.index(value,[start,[stop]])
通过元素value从左往右找列表索引，有填写区间就在区间内寻找，默认整个列表，匹配第一个就返回，如果找不到，则返回元素异常valueError，O(n)
list.count(value):
找元素在列表中数量，O(n)
len(list):
返回列表内元素个数（第一层）

4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计 

while True:
	a = int(input('请输入一个数字：'))
	x = input('请输入操作符（+ - * /）:')
	b = int(input('请输入一个数字：'))	
	n = ('+','-','*','/')
	if x in n:
		if x == '+':
			c = a + b
		elif x == '-':
			c = a - b
		elif x == '*':
			c = a * b
		elif x == '/':
			c = a / b
		print('运算结果为', c)

