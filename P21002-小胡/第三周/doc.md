### 说明列表的浅拷贝和深拷贝的区别
+ 浅拷贝可以使用列表自带的copy()函数或者copy模块的copy()函数,深拷贝只能使用copy模块的deepcopy()
+ 如果拷贝的对象里的元素只有值，没有引用，那浅拷贝和深拷贝没有差别，都会将原有对象复制一份，产生一个新对象，对新对象里的值进行修改不会影响原有对象，新对象和原对象完全分离开
+ 如果拷贝的对象里的元素包含引用（像一个列表里储存着另一个列表，存的就是另一个列表的引用），那浅拷贝和深拷贝是不同的，浅拷贝虽然将原有对象复制一份，但是依然保存的是引用，所以对新对象里的引用里的值进行修改，依然会改变原对象里的列表的值，新对象和原对象并没有完全分离开。而深拷贝则不同，它会将原对象里的引用也新创建一个，即新建一个列表，然后放的是新列表的引用，这样就可以将新对象和原对象完全分离开。
### 说明列表和元组的相同点和不同点
> ####相同点
+ 都是序列
+ 都可以存储任何数据类型
+ 可以通过索引访问
> ###不同点
+ 列表使用方括号[]创建，元素使用括号()创建
+ 列表可变，元组不可变
+ 列表可复制，元组无法复制
+ 列表占用内存比元组小
+ 习惯上元组多用于用于存储异构元素，比如(ip,port)。 而列表多用于存储同构元素，比如[int1,in2,in3]。
### 字符串支持的所有方法及说明
字符串排版函数因为不常用，所以不再列举
+ join(iterable) 将可迭代对象连接起来，使用string作为分隔符, 可迭代对象本身元素都是字符串
+ split(sep=None, maxsplit=-1) 将字符串按照分隔符分割成若干字符串，并返回列表
+ rsplit(sep=None, maxsplit=-1) 上面是从左往右分割，这边是从右往左分割
+ partition(sep) 从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回头、2个空元素的三元组
+ rpartition(sep) 上面是从左往右分割，这边是从右往左分割
+ splitlines([keepends]) 按照行来切分字符串
+ upper() 全大写
+ lower() 全小写
+ replace(old, new[, count])  字符串中找到匹配替换为新子串，返回新字符串
+ strip([chars]) 从字符串两端去除指定的字符集chars中的所有字符，如果chars没有指定，去除两端的空白字符
+ lstrip([chars]) 上面是两端都去除，这边是左边都去除
+ rstrip([chars]) 上面是左边都去除，这边是右边都去除
+ find(sub[, start[, end]]) 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到返回-1
+ rfind(sub[, start[, end]]) 上面是从左往右找，这边从右往左找，返回的索引和上面的一样是正索引
+ index(sub[, start[, end]]) 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError
+ rindex(sub[, start[, end]]) 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError
+ len(string) 返回字符串的长度
+ count(sub[, start[, end]]) 在指定的区间[start, end)，从左至右，统计子串sub出现的次数
+ endswith(suffix[, start[, end]]) 在指定的区间[start, end)，字符串是否是suffix结尾
+ startswith(prefix[, start[, end]]) 在指定的区间[start, end)，字符串是否是prefix开头
+ isalnum() 是否是字母和数字组成
+ isalpha() 是否是字母
+ isdecimal() 是否只包含十进制数字
+ isdigit() 是否全部数字(0~9)
+ isidentifier() 是不是字母和下划线开头，其他都是字母、数字、下划线
+ islower() 是否都是小写
+ isupper() 是否全部大写
+ isspace() 是否只包含空白字符 
+ format() 格式化字符串


