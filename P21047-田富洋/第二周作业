1. 简要说明Python垃圾回收机制
部分Python垃圾回收机制的简单说明：
  引用计数：
    python每在内存中建立一个对象时（同时会占用一段内存空间），都会为此对象建立一个对应的字段，此字段用来存储这个对象被引用的次数。此对象每被引用一次，字段值+1；当引用次数变为0时，这个对象（垃圾）将会被清除，对应占用的内存空间也会回收。
    但是引用计数的垃圾回收方法会引发两个问题：
    1、使用字段来存储对象被引用次数需要占用额外的资源
    2、循环引用的对象无法使用此机制回收，而且会导致内存泄漏。
    例：
    >>> a = [1,2,3]
    >>> b = [4,5,6]
    >>> a.append(a)
    >>> b.append(b)
    a和b被彼此互相引用，其引用计数器都为1，但是却没有被其他任何对象引用，已经可以回收，但由于引用计数器的关系无法回收，这时候就需要一套其他的内存回收机制
  标记清除：
    标记清除可以有效解决循环引用的问题。
      涉及到引用计数、循环引用环的拆解、root链表和unreachable链表的工作原理。
      暂时无法完整的理解其工作机制，需要进一步学习！！！
  分代回收：
    将对象分为三代：0,1,2；0代表幼年对象，1代表青年对象，2代表老年对象。新生的对象会被归类为0代，当第0代中的对象总数达到上限时，就会进行一次垃圾回收。如果0代中的对象在第一次垃圾回收中存活下来，将会被归入到第1代，
    如果第1代的对象在第一次垃圾回收中存活下来，就会被归入到第2代。
    第2代的最小总数达到上限时，也会进行一次垃圾回收。如果第2代对象在一次垃圾回收中存活下来，就会被归入到第3代。
    这3代的垃圾回收频率是不同的，0代最为频繁，1代次之，以此类推。它们的垃圾回收频率会随着生存时间的增大而降低。
2. 什么是斐波那契数列、素数、质数和猴子吃桃问题（文字说明即可）？
  斐波拉契数列：此数列的第0位为0，第1位为1，从第2位开始，每一位的值等于前两位数的和。
  素数：又称为质数，指的是在大于1的自然数中，除了1和它本身之外，不能被其他任何数整除的数
  质数：同素数
  猴子吃桃：指的是猴子有若干个桃子，第一天吃了一半以后又吃了1个，第二天吃了剩下的一半以后又吃另1个，如此循环，到第十天的时候只剩下1个桃子。问猴子最开始有多少个桃子？

3. 请写出列表支持的所有方法及说明（例如: append 向列表末尾添加元素）
  创建空列表:
    LIST_NAME=()
    LIST_NAME=list[]
    例:
    >>> li=()
    >>> li=list[]
  创建非空列表:
    LIST_NAME=list[VALUE1,VALUE2,...,VALUEn]
    例:
    >>> li=[1,2,3,4]
  读取列表中的指定位置的元素：
    LIST_NAME[[-]INDEX[:]]
      -INDEX 代表的是倒数第INDEX位
      INDEX: 代表从第INDEX位开始向后截取
    例：
    >>> li=[1,2,3,4]
    >>> li[1]
    >>> 2
    >>> li[-2]
    >>> 3
  查询列表中的值的位置:
    LIST_NAME.index(VALUE[,START_INDEX[,END_INDEX]])
    例:
    >>> li=[1,2,3,4]
    >>> li.index(3,0,3)
    >>> 2
  返回列表中某元素的匹配次数:
    LIST_NAME.count(VALUE)
    例:
    >>> li=[1,2,3,1]
    >>> li.count(1)
    >>> 2
  查询列表中元素的总个数：
    len(LIST_NAME)
    例:
    >>> li=[1,2,3,4]
    >>> len(li)
    >>> 4
  返回列表元素中的值最大的那个元素：
    max(LIST_NAME)
    例：
    >>> li=[1,2,3,4]
    >>> max(li)
    >>> 4
  返回列表元素中的值最小的那个元素：
    min(LIST_NAME)
    例：
    >>> li=[1,2,3,4]
    >>> min(li)
    >>> 1
  判断指定的值是否存在于列表中，是返回True，否则返回False
    VALUE in LIST_NAME
    例:
    >>> li=[1,2,3,4]
    >>> 2 in li
    >>> True
  判断指定的值是否不存在于列表中，是返回True，否则返回False
    VALUE not in LIST_NAME
    例:
    >>> li=[1,2,3,4]
    >>> 2 not in li
    >>> False
  修改列表中的元素:
    LIST_NAME[INDEX]=VALUE
    例:
    >>> li=[1,2,3,4]
    >>> li[0]="a"
    >>> print(li)
    >>> [a,2,3,4]
  向列表中插入元素：
    LIST_NAME.insert(INDEX,VALUE)
    如果insert指定的index超过了上界，会在尾部追加；超越了下界，则会在头部追加。
    例:
    >>> li=[1,2,3,4]
    >>> li.insert(0,"a")
    >>> print(li)
    >>> ['a',1,2,3,4]
  向列表尾部增加元素：
    LIST_NAME.append(VALUE)
    例:
    >>> li=[1,2,3,4]
    >>> li.append("a")
    >>> print(li)
    >>> [1,2,3,4,'a']
  将可迭代对象的元素追加进来：
    LIST_NAME.extend(ITERATABLES)
    例:
    >>> li=[1,2,3,4]
    >>> li.extend(range(5))
    >>> li
    >>> [1,2,3,4,0,1,2,3,4]
  删除列表内指定位置的元素
    del LIST_NAME(INDEX)
    例:
    >>> li=[1,2,3,4]
    >>> del li(1)
    >>> print(li)
    >>> [1,3,4]
  删除列表内指定位置的元素，并返回该元素的值
    LIST_NAME.pop([INDEX])
      可以不指定位置，默认删除最后一位
    例：
    >>> li=[1,2,3,4,5]
    >>> li.pop()
    >>> 5
    >>> print(li)
    >>> [1,2,3,4]
    >>> li.pop(1)
    >>> 2
    >>> print(li)
    >>> [1,3,4]
  删除列表中第一个匹配到指定值的元素
    LIST_NAME.remove(VALUE)
    例：
    >>> li=[1,2,3,4,1]
    >>> li.remove(1)
    >>> print(li)
    >>> [2,3,4,1]
  将列表中的元素顺序进行倒叙，直接修改原列表内容
    LIST_NAME.reverse()
    例：
    >>> li=[1,2,3,4]
    >>> li.reverse()
    >>> print(li)
    >>> [4,3,2,1]
  将列表中的元素按照指定参数进行排序，直接修改原列表内容
    LIST_NAME.sort([cmp=NONE,][key=NONE][reverse=True|False])
      cmp和key参数尚无法理解，需要后续继续学习
      reverse参数，True为降序，False为升序
    例：
      >>> li=[0,2,1,4,3]
      >>> li.sort()
      >>> print(li)
      >>> [0,1,2,3,4]
      >>> li.sort(reverse=True)
      >>> print(li)
      >>> [4,3,2,1,0]
  将两个列表连接，但并不修改原列表内容：
    LIST_NAME + LIST_NAME
    例:
    >>> li=[1,2,3,4]
    >>> lj=[5,6,7,8]
    >>> li + lj
    >>> [1,2,3,4,5,6,7,8]
  将列表内元素重复n次，但并不修改原列表内容：
    LIST_NAME*n
    or
    n*LIST_NAME
    例:
    >>> li=[1,2,3,4]
    >>> li*n
    >>> [1,2,3,4,1,2,3,4,1,2,3,4]
    >>> n*li
    >>> [1,2,3,4,1,2,3,4,1,2,3,4]
4. 实现一个简易的计算器，效果如下：
    （1）. 运行后提示让用户输入一个数字
    （2）. 提示输入操作符（+ - * /）
    （3）. 再次提示输入一个数字
    （4）. 打印计算结果
    （5）. 在不退出程序的前提下，可以允许用户继续输入新一组数据计
while True:                                                                     # 死循环可以使用户在不退出程序的时候继续输入数据进行计算
    a=int(input("Please input first number or 'stop' to exit the program:  "))  # a变量存储第一个数字，或'stop'，由于需要存储'stop'，所以不能首先转换为int
    if a == "stop":break                                                        # 如果为stop则退出循环，即退出程序，如果不为stop则继续
    a=int(a)
    ar=str(input("Please input a kind of arithmetic(+ - * /):  "))              # ar变量存储操作符，操作符必须转换为字符串后存储在变量中
    b=int(input("Please input second number:  "))                               # b变量存储第二个数字
    result=0                                                                    # result变量存储计算结果
    if ar == "+":                                                               # 使用判断语句来根据用户输入的不同符号来进行对应的计算
        result=a+b
    elif ar == "-":
        result=a-b
    elif ar == "*":
        result=a*b
    elif ar == "/":
        result=a/b
    print("This is the result:  ",result)                           # 最后输出计算结果
    print()
